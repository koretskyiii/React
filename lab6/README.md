# Практична №6 - Контекст, мемоїзація. Організація коду

## 1. Component composition
Дана практика полягає в створенні невеликих та повторно використовуваних компонентів, з поєднань яких утворюються більші структури (компоненти, 
 сторінки і т.д.). Що це дає на практиці: 
 * Можливість перевикористання компонентів у різних частинах програми
 * Розуміння та полегшення роботи зі складними проєктами
 * Керованість та гнучкість у розробці
 * Зменшення дублювання коду, а отже виконання принципу DRY
 * Полегшення підтримки та тестування коду
У моєму проєкті були створені reusable компоненти в директорії **ui**/, в які я помістив ті компоненти, які використовуються частіше 2-3 разів.

Приклад такого компоненту
``` js 
const CustomButton = ({ submit, text, color, handler }) => {
  return submit ? (
    <Button
      variant="contained"
      type="submit"
      fullWidth
      sx={{ width: "75%" }}
      color='primary'
    >
      {text}
    </Button>
  ) : (
    <Button
      variant="outlined"
      color={color}
      sx={{ marginRight: 1 }}
      onClick={handler}
    >
      {text}
    </Button>
  );
};
```

## 2. State management  
Керування станом (state management) є одним з найважливіших аспектів, який визначає, як компоненти взаємодіють з даними і як ці дані змінюються в межах застосунку.
Дуже важлива практика в реакті, яка дозволяє:
* Централізовано керувати всіма змінами стану і уникати непотрібного дублювання стану в кількох компонентах.
* Реактивність у нашому випадку бібліотеки керування станом Effector допомагає автоматично оновлюти всі компоненти, що підписуються на певний стан, коли цей стан змінюється. Завдяки цьому можна організувати реактивну архітектуру, де зміни в одному місці автоматично оновлюють всі залежні компоненти
* Оптимізація продуктивності
* Зменшення складності додатку
 [store](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/store.jsx)
## 3. Кастомні хуки
Кастомні хуки знаходяться у відповідній папці
[hooks/](https://github.com/koretskyiii/React/tree/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/hooks)

**useEditExpence** відповідає за редагування витрат у списку

**useToggleSummary** відповідає за перемикання показу сумарних витрат

**useFilter** допомагає керувати фільтром витрат, оновлюючи стан через Effector (використовує useStore для доступу до глобального стану):

<hr>
Кастомні хуки дозволяють розвивати класичні хуки, які дуже ефективно керують станом у компонентах, ще далі, і в нашому проєкті винести логіку, що можна використовувати в різних компонентах. Це зберігає код чистим і зручним для повторного використання. 
<hr/>

## 4. Керування станом форм та валідація з React Hook Form та yup
Реалізація форми лежить у файлі [FormExpense.jsx](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/components/ExpenseForm.jsx)

За допомогою бібліотек React Hook Form та yup ми можемо керувати станом форми та її валідацією, не витрачаючи зайвих зусиль. Це не вимагає писати від нас багато коду. Досить легко в React Hook Form працювати з полями форми, надаючи відповідні методи, наприклад для реєстрації полів (register), обробки сабміту (handleSubmit), доступу до помилок валідації (formState: { errors }) тощо. Валідація з Yup, в свою чергу, мега зручна, тому що в одній валідаційній схемі ми, по суті, описуємо всі правила для ввідних даних, позбавляючись потреби в тому числі писати це в полях вводу даних. 

## 5. Типізація даних

[Лінк 1](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/components/ui/TextInput/TextInput.jsx#L21C1-L28C5)

[Лінк 2](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/components/ui/Selection/Selection.jsx#L26C1-L31C5)

<hr>
Було додано типізацію пропсів за допомогою PropTypes у компонентах, щоб покращити перевірку типів
</hr>

## 6. Мемоїзація
[Лінк](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/components/ExpenseList.jsx#L18)

Мемоїзація була використана для покращення продуктивності застосунку в компоненті ExpenseList.jsx. Це дозволяє уникнути зайвих ререндерів списку, якщо на це немає необхідності. Завдяки цьому при тому ж натисненні показу сумарної кількості товарів ререрндеринг списку витрат відбуватися не буде, що дуже добре для економії ресурсів нашого проєкту.

## 7. Lazy loading
[Лінк](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/App.jsx#L9C1-L9C74)

Lazy loading був використаний для того щоб не рендерити показ сумарної кількості товарів та суми витрати за них до того моменту, поки це не буде необхідно. Таким чином ми покращуємо час першого завантаження застосунку. Це особливо корисно для великих застосунків, де є багато неочевидних компонентів, які не завжди видимі або потрібні користувачу. В нашому випадку насправді через розмір застосунку в цьому немає прямої необхідності, такі лейзі лодінги треба додавати до набагато громіздкіших застосунків, де витрачається досить багато часу на завантаження певних масивів даних, зображень тощо.

## 8. CSS in JS
[Приклад 1](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/components/ExpenseList.jsx#L32C5-L33C74)

[Приклад 2](https://github.com/koretskyiii/React/blob/a135907e6f3f1068e3954d5e399edafbdc29fecb/lab6/src/components/ui/CustomButton/CustomButton.jsx#L5C1-L11C6)

В даному додатку використовуються стилі CSS-in-JS за допомогою бібліотеки Material-UI (MUI). Це дозволяє створювати стилі безпосередньо в JS, що робить їх тісно інтегрованими з компонентами React. Це дає можливість визначати стилі через об'єкти JavaScript, що дозволяє динамічно змінювати стилі залежно від стану компонента чи пропсів. Це забезпечує високу гнучкість і дозволяє уникнути глобальних стилів, забезпечуючи ізольованість кожного компонента.
